# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonParcellaireDockWidget
                                 A QGIS plugin
 Manage your parcels
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by jhemmi.eu
        email                : jean@jhemmi.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from .initialisation_var_exception import *

import os
import shutil # pour la copie de fichier
from datetime import datetime
from qgis.gui import ( QgsMessageBar)
from qgis.core import (
   QgsSettings, QgsProject, QgsVectorLayer, QgsVectorLayerJoinInfo 
  #QgsApplication, QgsWkbTypes, QgsVectorFileWriter, QgsCoordinateReferenceSystem, QgsFeature, QgsFields, QgsField
)


from PyQt5.QtCore import (Qt) #, QFileInfo)  
from PyQt5.QtWidgets import (QDialogButtonBox, QFileDialog, QSizePolicy) # QGridLayout QDialog 
from qgis.PyQt import QtWidgets, uic # QtGui
from qgis.PyQt.QtCore import ( pyqtSignal) #, QVariant)

try:
    import pandas as pd
    #import json
    print("\nVersion pandas : {0} ".format(pd.__version__))
#    import fiona; 
#    print("Drivers fiona : {0}".format(fiona.supported_drivers))
except:
    erreur_import("Pandas") #erreur_import("Pandas ou geopandas")
#try:
#    import processing
#    from processing import ( QgsProcessingException) # algorithmHelp
#except:
#    erreur_import("Processing")
#    
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mon_parcellaire_dockwidget_base.ui'))
    
class MonParcellaireDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MonParcellaireDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # Barre de comm
        self.bar = QgsMessageBar()
        self.bar.setSizePolicy( QSizePolicy.Minimum, QSizePolicy.Fixed )
        
        print( "** Démarrage de MonParcellaire {0}".format(APPLI_VERSION))
        # Slot boutons 
        self.Prepare_buttonBox.button( QDialogButtonBox.Ok ).pressed.connect(self.slotVerifierRepertoireGPKGJointure)
        self.Prepare_buttonBox.button( QDialogButtonBox.Save ).pressed.connect(self.ecrireSettings)
        # Slot toolbouton 
        self.Repertoire_toolButton.pressed.connect( self.slotLectureRepertoireGPKG)  
#        self.MultiPoint_checkBox.stateChanged.connect( self.slotBasculeMultiPoints)

        CHOIX_TOUT_VOIR, REPERTOIRE_GPKG,  FREQUENCE_SAUVEGARDE = self.lireSettings()
        
        self.slotInitCombo( self.FrequenceSauvegarde_comboBox, LISTE_FREQUENCE_SAUVEGARDE, FREQUENCE_SAUVEGARDE,  "des fréquences de sauvegarde")

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def ecrireSettings(self):
        """On écrit dans settings les saisies"""
        s = QgsSettings( APPLI_NOM)
        choixToutVoir = "YES" if self.Voir_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Tout_voir", choixToutVoir)
        s.setValue("MonParcellaire/repertoireGPKG", self.Repertoire_lineEdit.text())
        s.setValue("MonParcellaire/FrequenceSauvegarde", self.FrequenceSauvegarde_comboBox.currentText())
#        libItineraire = "QGIS" if self.QGIS_radioButton.isChecked() else "QN"
#        s.setValue("MonParcellaire/LibItineraire", libItineraire)
        #my_print( "Settings sauvegardées")
        return

    def lireSettings( self):
        s = QgsSettings( APPLI_NOM)
        CHOIX_TOUT_VOIR = s.value("MonParcellaire/Tout_voir", "NO")
        self.Voir_checkBox.setChecked( Qt.Checked) if CHOIX_TOUT_VOIR == "YES" else self.Voir_checkBox.setChecked( Qt.Unchecked)
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", "/media/jean/DATA/GIS/DATA/DATA_MP")
        self.Repertoire_lineEdit.setText( REPERTOIRE_GPKG )
        FREQUENCE_SAUVEGARDE = s.value("MonParcellaire/FrequenceSauvegarde", LISTE_FREQUENCE_SAUVEGARDE[0])
        # Choisir library calcul itineraire
        #LIB_ITINERAIRE = s.value("MonParcellaire/LibItineraire", "QGIS")
        #my_print( "Settings lus {}".format( REPERTOIRE_GPKG))
        return CHOIX_TOUT_VOIR, REPERTOIRE_GPKG, FREQUENCE_SAUVEGARDE #, LIB_ITINERAIRE
    
    def nommageVecteur( self, Repertoire, nomVecteur, Extension=EXT_geojson, doitExister="Oui"):
        """ Calcule le nom du vecteur et vérifie si le chemin au vecteur existe
        Rend le nom """
        # Assert
        if not os.path.isdir( Repertoire):
            erreur_repertoire( Repertoire)
        chemin_complet = os.path.join( Repertoire, nomVecteur + Extension)
        if  doitExister == "Oui" and not os.path.isfile( chemin_complet):
            erreur_vecteur( Repertoire,  nomVecteur + Extension)
        return chemin_complet
    
    def nommagesGPKG( self, Repertoire, nomTable, nomGPKG=MonParcellaire_GPKG, doitExister="Oui"):
        """ Calcule le nom de table et vérifie si le chemin au GPKG existe
        Rend le nom du gpkg, un libelle et le nom pour ouvrir avec QGIS API"""
        # Assert
        if not os.path.isdir( Repertoire):
            erreur_repertoire( Repertoire)
        CHEMIN_GPKG = os.path.join( Repertoire, nomGPKG)
        if not os.path.isfile( CHEMIN_GPKG) and doitExister == "Oui":
            erreur_gpkg( nomGPKG,  CHEMIN_GPKG)
        return CHEMIN_GPKG, "layer='{}'".format(nomTable), CHEMIN_GPKG + GPKG_LAYERNAME + nomTable

    def sauvergardeGPKG(self, repertoireGPKG, nomCourtGPKG, frequence, suiteSauvegarde, nomTable="xxx"):
        """ GPKG est sauvés selon la fréquence et si nécessaire"""
        REPERTOIRE_SAUVEGARDE = os.path.join( repertoireGPKG, suiteSauvegarde)
        if not os.path.isdir( REPERTOIRE_SAUVEGARDE):
            os.mkdir( REPERTOIRE_SAUVEGARDE)
        # Déterminer les noms des gpkg pour les copier
        CHEMIN_GPKG, _, cheminCompletTable = self.nommagesGPKG( repertoireGPKG, nomTable, nomCourtGPKG)  
        dateMaintenant = datetime.now()
        if frequence == LISTE_FREQUENCE_SAUVEGARDE[0]: # prochain run
            dateFormatee=dateMaintenant.strftime("%Y%m%d%H%M")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[1]: # par jour
            dateFormatee=dateMaintenant.strftime("%Y%m%d")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[2]: # par semaine
            dateFormatee=dateMaintenant.strftime("%Y%mSemaine%U")
        else: # par mois
            assert( frequence == LISTE_FREQUENCE_SAUVEGARDE[3])
            dateFormatee=dateMaintenant.strftime("%Y%m")
        CHEMIN_GPKG_SAVE = os.path.join( REPERTOIRE_SAUVEGARDE,  nomCourtGPKG) + "_SAUVEGARDE_" + dateFormatee
        if not os.path.isfile( CHEMIN_GPKG_SAVE):
            shutil.copy( CHEMIN_GPKG, CHEMIN_GPKG_SAVE)
        return CHEMIN_GPKG, cheminCompletTable

    def slotInitCombo( self, comboAInitialiser, LISTE_VALEURS, UNE_VALEUR,  libelleErreur):
        """Initialise un combo avec une liste de valeur et avec la position de la valeur correspondante trouvé dans Settings
        """
        comboAInitialiser.setCurrentIndex( 0)
        if len( LISTE_VALEURS) == 0:
            comboAInitialiser.clear( )
            my_print( self.tr("Pas de liste {0} pré défini".format( libelleErreur), T_WAR,  "BAR", self))
        else:
            comboAInitialiser.clear( )
            comboAInitialiser.addItems( LISTE_VALEURS )
            # Retrouver le mode de trace dans  settings
            for idx, valeur in enumerate( LISTE_VALEURS):
                if ( valeur == UNE_VALEUR):
                    comboAInitialiser.setCurrentIndex( idx)
                    break
                    
    def slotLectureRepertoireGPKG(self):
        # Répertoire
        s = QgsSettings( APPLI_NOM)
        TOM_REPERTOIRE = s.value( "MonTomParcellaire/Répertoire_gpkg", "Arretez vous au répertoire")
        dirName = QFileDialog.getExistingDirectory( self, self.tr("Choisir le répertoire de votre GPKG"),
                     TOM_REPERTOIRE, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks);
        if len( dirName) == 0:
            return
        self.Repertoire_lineEdit.setText( dirName )
        return
        
    def fusionnerJointure(self, repertoireGPKG, cheminCompletTable, nomJointure=MonParcellaire_JOI):
        """ Recherche de la jointure"""
        ###CHEMIN_GPKG, libelle, CHEMIN_JOINTURE_GPKG = self.nommagesGPKG( repertoireGPKG, nomJointure, nomJointure, "Non pre existance")  
        monProjet = QgsProject.instance()
        if monProjet.fileName() == None or monProjet.fileName() == "":
            my_print( "Projet en cours de création")
        else:
            my_print( "Projet {}".format(monProjet.fileName()))
            my_print( "Projet {}".format(monProjet.fileInfo()))
        # Déterminer le nom de la jointure qui doit exister
        CHEMIN_JOINTURE = self.nommageVecteur( repertoireGPKG, nomJointure, EXT_csv)
        # TODO: Faire la jointure par attribut
        parcelle =  QgsVectorLayer(cheminCompletTable, MonParcellaire_PAR, 'ogr')
        monProjet.addMapLayer(parcelle)
        # Nommage csv et recherche du delimiteur
        for delimiteur in DELIMITEUR_CONNUS:
            nomCsv="file:///{1}?delimiter={0}".format( delimiteur, CHEMIN_JOINTURE)
            try:
                csv = QgsVectorLayer(nomCsv, MonParcellaire_JOI, 'delimitedtext')
            except:
                my_print( "Erreur pour délimiteur {0} Nom du csv {1}".format( delimiteur, nomCsv))
                continue
            break
        my_print( "OK délimiteur est {0} Nom du csv {1}".format( delimiteur, nomCsv))
        monProjet.addMapLayer(csv)
        # Jointure
        # TODO: récupérer les champs de jointure
        champVecteur='nom'
        champCsv='nom'
        maJointure=QgsVectorLayerJoinInfo()
        maJointure.setJoinFieldName(champCsv)
        maJointure.setTargetFieldName(champVecteur)
        maJointure.setUsingMemoryCache(False)
        maJointure.setPrefix("jhemmi_")
        maJointure.setJoinLayer(csv)
        # TODO: récupérer les champs de jointure
        maJointure.setJoinFieldNamesSubset(['cépage', 'cadastre'])
        parcelle.addJoin(maJointure)
        return CHEMIN_JOINTURE
        
    def slotVerifierRepertoireGPKGJointure( self):
        """ Gestion la sauvegarde du GPKG : trois cas de frequences de sauvegarde, 
            Gestion de la jointure    
        """
        my_print( self.tr("Vérifier répertoire, GPKGs et jointure ... Version {0}".format(APPLI_VERSION)))
        
        # Utiliser les dernières saisies
        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
        FREQUENCE_SAUVEGARDE = self.FrequenceSauvegarde_comboBox.currentText()
        self.ecrireSettings()        
        ###############
        # Sauvegardes 
        ###############
        CHEMIN_VECTEUR_GPKG, cheminCompletTable = self.sauvergardeGPKG( REPERTOIRE_GPKG, MonParcellaire_GPKG, FREQUENCE_SAUVEGARDE, MonParcellaire_SAV, MonParcellaire_PAR)
        CHEMIN_RASTER_GPKG, _ = self.sauvergardeGPKG( REPERTOIRE_GPKG, MesFondsDePlan_GPKG, LISTE_FREQUENCE_SAUVEGARDE[3], MonParcellaire_SAV)
        ###############
        # Jointure 
        ###############                   
        CHEMIN_JOINTURE = self.fusionnerJointure( REPERTOIRE_GPKG, cheminCompletTable)
        self.ecrireSettings()        
        my_print( self.tr("Fin Vérifier répertoire et GPKG Jointure OK {}".format(CHEMIN_JOINTURE), T_OK))
