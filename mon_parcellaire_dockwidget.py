# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mon_parcellairep_dockwidget
                                 A QGIS plugin
 Manage your parcels
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by jhemmi.eu
        email                : jean@jhemmi.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from .initialisation_var_exception import *
#from .mes_rangs_centipede import ( chercherDernierPosCentipede, creerTamponsParcelles, filtreQualitesCentipede,  \
#    projectionPourJointureSpatiale, choisirGeoJSONsInterieurExterieur, creerPointsLignesBrises) 

from qgis.core import ( 
   QgsSettings, QgsProject, QgsVectorLayer, QgsVectorLayerJoinInfo, QgsLayerTreeGroup,QgsCoordinateReferenceSystem, \
   QgsProcessingFeatureSourceDefinition, QgsFeatureRequest)
  #QgsApplication, QgsWkbTypes, QgsVectorFileWriter, QgsFeature, QgsFields, QgsField,

from PyQt5.QtCore import ( Qt, QUrl) #, QFileInfo)
from PyQt5.QtGui import ( QDesktopServices)
from PyQt5.QtWidgets import ( QDialogButtonBox, QFileDialog, QSizePolicy) # QGridLayout QDialog 
from qgis.PyQt import ( QtWidgets, uic) # QtGui
from qgis.PyQt.QtCore import ( pyqtSignal) #, QVariant)
from qgis.gui import ( QgsMessageBar)

try:
    import processing
    if MonParcellaire_TRACE=="YES": dir( processing)
    from processing import ( QgsProcessingException) # algorithmHelp
    if MonParcellaire_TRACE=="YES": 
        print("Processing : {0} ".format( dir( QgsProcessingException.__traceback__)))
except:
    erreurImport("Processing")
    
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mon_parcellaire_dockwidget_base.ui'))
    
""" TRAITEMENTS ou PROCESSING"""
def traitementSelectionnerVignes(source, champ_selection = 'code_culture', libelle='VRC'):
    """ Selection"""
    algo_name, algo_simplifie ="qgis:selectbyattribute",  "Filtrer vignes..."
    resultat_selection = processing.run(algo_name, 
        {'INPUT': source, 'FIELD': champ_selection, 'OPERATOR':0,'VALUE':libelle,'METHOD':0})
    if resultat_selection == None:
        monPrint( "Erreur bloquante durant processing {0}".format( algo_simplifie), T_ERR)
        erreurTraitement(algo_name)
    monPrint( "Sélection dans {0}".format( resultat_selection))

def traitementSauver(source, sortie):
    """ Sauver"""
    algo_name, algo_simplifie ="native:savefeatures",  "Sauver vignes..."
    result = processing.run(algo_name, 
        {'INPUT': source , 'OUTPUT': sortie,'LAYER_NAME':'', \
			'DATASOURCE_OPTIONS':'','LAYER_OPTIONS':'','ACTION_ON_EXISTING_FILE':0})
    if result == None:
        monPrint( "Erreur bloquante durant processing {0}".format( algo_simplifie), T_ERR)
        erreurTraitement(algo_name)
    monPrint( "Sauver en {0}".format( result))
    return result

def traitementDupliquer_nom_parcelle(source, sortie):
    algo_name, algo_simplifie ="native:fieldcalculator",  "Dupliquer nom_parcelles..."
    result = processing.run(algo_name, 
        {'INPUT': source , 'OUTPUT': sortie, \
			'FIELD_NAME':MonParcellaireNomAttribut,'FIELD_TYPE':2,'FIELD_LENGTH':15,'FIELD_PRECISION':0,
			'FORMULA':' "nom_parcelle" '})
    if result == None:
        monPrint( "Erreur bloquante durant processing {0}".format( algo_simplifie), T_ERR)
        erreurTraitement(algo_name)
    monPrint( "Nom est dans {0}".format( result))
    return result

def traitementJointureLocalisation(source, jointure, sortie, libelle=""):
    """ {'INPUT':source, 'JOIN':jointure,
    'PREDICATE':[0,1,3,5],'JOIN_FIELDS':['nom'],'METHOD':0,'DISCARD_NONMATCHING':True,'PREFIX':'',
    'OUTPUT':sortie} """
    algo_name,  algo_simplifie ="qgis:joinattributesbylocation",  "Jointure par localisation ..."
    # TODO: ? orientatio ou tion
    result = processing.run(algo_name, 
        {'INPUT': source, 'JOIN':jointure, 'PREDICATE':[0,1,3,5],'JOIN_FIELDS':['nom',  'orientatio'],'METHOD':0,'DISCARD_NONMATCHING':True,'PREFIX':'', 'OUTPUT': sortie})
    if result == None:
        monPrint( "Erreur bloquante durant processing {0}".format( algo_simplifie), T_ERR)
        erreur_traitement(algo_name)
    return result


class MonParcellaireDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MonParcellaireDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # Barre de comm
        self.bar = QgsMessageBar()
        self.bar.setSizePolicy( QSizePolicy.Minimum, QSizePolicy.Fixed )

        self.plugin_dir = os.path.dirname(__file__) 
        
        #print( "** Démarrage de MonParcellaire {0}".format(APPLI_VERSION))
        CHOIX_TOUT_VOIR, CHOIX_MES_PARCELLES, NOM_CSV_MES_PARCELLES, CHOIX_ORIENTATION, CHOIX_TERROIR, \
            CHOIX_JOINTURE, REPERTOIRE_GPKG, FREQUENCE_SAUVEGARDE, \
            ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE = self.lireSettings()
        # Slot boutons 
        self.Prepare_buttonBox.button( QDialogButtonBox.Ok ).pressed.connect(self.slotTraiterRepertoireGPKGJointure)
        self.Prepare_buttonBox.button( QDialogButtonBox.Save ).pressed.connect(self.ecrireSettings)
        self.TestButton.pressed.connect(self.traiterCentipedePos)

        # Slot toolbouton 
        self.Repertoire_toolButton.pressed.connect( self.slotLectureRepertoireGPKG)
        self.Jointure_checkBox.stateChanged.connect( self.slotBasculeJointure)
        self.Mes_Parcelles_toolButton.pressed.connect( self.slotLectureMesParcelles)
        self.Mes_Parcelles_checkBox.stateChanged.connect( self.slotBasculeMesParcelles)

        # Cas des combo
        self.initialiserCombo( self.FrequenceSauvegarde_comboBox, LISTE_FREQUENCE_SAUVEGARDE, FREQUENCE_SAUVEGARDE,  "des fréquences de sauvegarde")
        CHEMIN_JOINTURE = None
        if CHOIX_JOINTURE == "YES":
            # Déterminer le nom de la jointure
            CHEMIN_JOINTURE = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
        if CHEMIN_JOINTURE != None:
            nomColonnes, nomColonnesUniques = self.lireAttributsJointure( CHEMIN_JOINTURE)
        else:
            nomColonnes=['Pas de jointure']
            nomColonnesUniques=['Pas de jointure']
        # Attributs pour la joindre
        self.initialiserCombo( self.AttributJointure_comboBox, nomColonnesUniques, ATTRIBUT_JOINTURE)
        # Liste AttributsAJoindre
        self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, nomColonnes, LISTE_ATTRIBUTS_A_JOINDRE,  "attributs à joindre")
        # Cas où jointure est attendu mais n'existe pas (ou plus)
        if CHOIX_JOINTURE == "YES" and CHEMIN_JOINTURE == None:
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
            CHOIX_JOINTURE == "NO"
        else:
            self.Jointure_checkBox.setChecked( Qt.Checked)
            
        # Appel à aide ou contrib
        self.Aide_bouton.pressed.connect(self.slotDemanderAide)
        self.Contribuer_bouton.pressed.connect(self.slotDemanderContribution)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        
    def slotDemanderContribution( self):
        """ Pointer vers page paiement pour QGIS""" 
        help_url = QUrl("https://qgis.org/funding/donate/")
        QDesktopServices.openUrl(help_url)
    
    def slotDemanderAide(self):
        """ Help html qui pointe vers gitHub""" 
        help_url = QUrl("https://github.com/jhemmi/MonParcellaire/wiki")
        QDesktopServices.openUrl(help_url)

    def ecrireSettings(self):
        """On écrit dans settings les saisies"""
        s = QgsSettings( APPLI_NOM)
        choixToutVoir = "YES" #if self.Voir_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Tout_voir", choixToutVoir)
        s.setValue("MonParcellaire/repertoireGPKG", self.Repertoire_lineEdit.text())
        s.setValue("MonParcellaire/FrequenceSauvegarde", self.FrequenceSauvegarde_comboBox.currentText())
        choixMesParcelles= "YES" if self.Mes_Parcelles_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/ImportMesParcelles", choixMesParcelles)
        s.setValue("MonParcellaire/nomMesParcelles", self.Mes_Parcelles_lineEdit.text())
        choixOrientation= "YES" if self.Orientation_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Orientation", choixOrientation)
        choixTerroir= "YES" if self.Terroir_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Terroir", choixTerroir)
        choixJointure = "YES" if self.Jointure_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/PresenceJointure", choixJointure)
        s.setValue("MonParcellaire/AttributJointure", self.AttributJointure_comboBox.currentText())
        # Multivalues
        items=self.AttributsAJoindre_listWidget.selectedItems()
        listeAJoindre = ""
        for item in range(len(items)):
            nomItem=str(self.AttributsAJoindre_listWidget.selectedItems()[item].text())
            if nomItem != MonParcellaireNomAttribut:
                if item == 0:
                    listeAJoindre=nomItem
                else:
                    listeAJoindre=listeAJoindre + SEP_CONFIG + nomItem
        s.setValue("MonParcellaire/AttributsAJoindre", listeAJoindre)
        #monPrint( "Settings sauvegardées")
        return

    def lireSettings( self):
        s = QgsSettings( APPLI_NOM)
        CHOIX_TOUT_VOIR = s.value("MonParcellaire/Tout_voir", "NO")
        CHOIX_MES_PARCELLES = s.value("MonParcellaire/ImportMesParcelles", "NO")
        self.Mes_Parcelles_checkBox.setChecked( Qt.Checked) if CHOIX_MES_PARCELLES == "YES" else self.Mes_Parcelles_checkBox.setChecked( Qt.Unchecked)
        NOM_CSV_MES_PARCELLES = s.value("MonParcellaire/nomMesParcelles", "Export geometries parcelles2025_Fronton.csv")
        self.Mes_Parcelles_lineEdit.setText( NOM_CSV_MES_PARCELLES )
        CHOIX_ORIENTATION = s.value("MonParcellaire/Orientation", "NO")
        self.Orientation_checkBox.setChecked( Qt.Checked) if CHOIX_ORIENTATION == "YES" else self.Orientation_checkBox.setChecked( Qt.Unchecked)
        CHOIX_TERROIR = s.value("MonParcellaire/Terroir", "NO")
        self.Terroir_checkBox.setChecked( Qt.Checked) if CHOIX_TERROIR == "YES" else self.Terroir_checkBox.setChecked( Qt.Unchecked)
        CHOIX_JOINTURE = s.value("MonParcellaire/PresenceJointure", "NO")
        self.Jointure_checkBox.setChecked( Qt.Checked) if CHOIX_JOINTURE == "YES" else self.Jointure_checkBox.setChecked( Qt.Unchecked)
        referentiel_plugin=os.path.join( self.plugin_dir, "data")
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", referentiel_plugin)
        if not os.path.isdir( REPERTOIRE_GPKG): # n'existe plus
            monPrint( "Répertoire {0} n'existant plus, retour au choix du référentiel du plugin {1}".\
                format( REPERTOIRE_GPKG, referentiel_plugin), T_WAR)
            REPERTOIRE_GPKG = referentiel_plugin
        self.Repertoire_lineEdit.setText( REPERTOIRE_GPKG )
        FREQUENCE_SAUVEGARDE = s.value("MonParcellaire/FrequenceSauvegarde", LISTE_FREQUENCE_SAUVEGARDE[0])
        ATTRIBUT_JOINTURE = s.value("MonParcellaire/AttributJointure", "Pas de jointure")
        PreparelisteAttributAJoindre = s.value("MonParcellaire/AttributsAJoindre", "Pas de jointure")
        LISTE_ATTRIBUTS_A_JOINDRE=PreparelisteAttributAJoindre.split( SEP_CONFIG)
        #monPrint( "Settings lus jointure {} pour attributs {}".format( CHOIX_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE))
        return CHOIX_TOUT_VOIR, CHOIX_MES_PARCELLES, NOM_CSV_MES_PARCELLES, CHOIX_ORIENTATION, CHOIX_TERROIR, CHOIX_JOINTURE, REPERTOIRE_GPKG, \
			FREQUENCE_SAUVEGARDE, ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE
    
    def sauvergardeSelonFrequence(self, repertoireASauver, nomCourt, frequence, suiteSauvegarde, presenceAttendue=False, nomTable="xxx"):
        """ Fichier (y compris GPKG) est sauvés selon la fréquence et si nécessaire
            nommage detaillé selon la fréquence"""
        REPERTOIRE_SAUVEGARDE = os.path.join( repertoireASauver, suiteSauvegarde)
        creerRepertoireOptionTemporaire( REPERTOIRE_SAUVEGARDE)
        # Déterminer les noms des gpkg pour les copier
        CHEMIN_GPKG, _, cheminCompletTable = nommagesGPKG( repertoireASauver, nomTable, nomCourt, presenceAttendue)  
        if CHEMIN_GPKG == None:
            monPrint( "Pas de sauvegarde pour {0}".format( nomCourt), T_WAR)            
            return None, None
        dateMaintenant = datetime.now()
        if frequence == LISTE_FREQUENCE_SAUVEGARDE[0]: # prochain run
            dateFormatee=dateMaintenant.strftime("%Y%m%d%H%M")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[1]: # par jour
            dateFormatee=dateMaintenant.strftime("%Y%m%d")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[2]: # par semaine
            dateFormatee=dateMaintenant.strftime("%Y%mSemaine%U")
        else: # par mois
            assert( frequence == LISTE_FREQUENCE_SAUVEGARDE[3])
            dateFormatee=dateMaintenant.strftime("%Y%m")
        CHEMIN_GPKG_SAVE = os.path.join( REPERTOIRE_SAUVEGARDE,  nomCourt) + "_SAUVEGARDE_" + dateFormatee
        if not os.path.isfile( CHEMIN_GPKG_SAVE):
            shutil.copy( CHEMIN_GPKG, CHEMIN_GPKG_SAVE)
        return CHEMIN_GPKG, cheminCompletTable


    def slotBasculeMesParcelles( self):
        """ 
        Bascule le choix Mes Parcelles
        """
        CHEMIN_JOINTURE=None
        if self.Mes_Parcelles_checkBox.isChecked():
            #_, _, _,_, _, _,REPERTOIRE_GPKG, _, \
            #ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE = self.lireSettings()
            self.Mes_Parcelles_lineEdit.setEnabled( True)
            self.Mes_Parcelles_toolButton.setEnabled( True)
        else:
            self.Mes_Parcelles_lineEdit.setEnabled( False)
            self.Mes_Parcelles_toolButton.setEnabled( False)

    def slotBasculeJointure( self):
        """ 
        Bascule le choix jointure et acces aux listes d'attribut à joindre
        """
        CHEMIN_JOINTURE=None
        if self.Jointure_checkBox.isChecked():
            _, _, _, _, _, _,REPERTOIRE_GPKG, _, \
            ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE = self.lireSettings()
            CHEMIN_JOINTURE = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
        if CHEMIN_JOINTURE != None and self.Jointure_checkBox.isChecked():
            self.AttributJointure_comboBox.setEnabled( True)
            self.AttributsAJoindre_listWidget.setEnabled( True)
            self.label_Jointure.setEnabled( True)
            self.label_AttributJointure.setEnabled( True)
            self.label_AttributsAJoindre.setEnabled( True)
            nomColonnes, nomColonnesUniques = self.lireAttributsJointure( CHEMIN_JOINTURE)
            # Attributs pour la joindre
            self.initialiserCombo( self.AttributJointure_comboBox, nomColonnesUniques, ATTRIBUT_JOINTURE)
            # Liste AttributsAJoindre
            self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, nomColonnes, LISTE_ATTRIBUTS_A_JOINDRE,  "attributs à joindre")
        else:
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
            self.AttributJointure_comboBox.setEnabled( False)
            self.AttributsAJoindre_listWidget.setEnabled( False)
            self.label_Jointure.setEnabled( False)
            self.label_AttributJointure.setEnabled( False)
            self.label_AttributsAJoindre.setEnabled( False)
            self.initialiserCombo( self.AttributJointure_comboBox, ["Pas de jointure"], "Pas de jointure")
            self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, ["Pas de jointure"], ["Pas de jointure"], "attributs à joindre")
            
    def initialiserCombo( self, comboAInitialiser, LISTE_VALEURS, UNE_VALEUR,  libelleErreur=None):
        """Initialise un combo avec une liste de valeur et avec la position de la valeur correspondante trouvé dans Settings
        """
        comboAInitialiser.setCurrentIndex( 0)
        if len( LISTE_VALEURS) == 0:
            comboAInitialiser.clear()
            if libelleErreur != None:
                monPrint( self.tr("Pas de liste {0} pré défini".format( libelleErreur)), T_WAR,  "BAR", self)
        else:
            comboAInitialiser.clear( )
            comboAInitialiser.addItems( LISTE_VALEURS )
            # Retrouver le mode de trace dans  settings
            for idx, valeur in enumerate( LISTE_VALEURS):
                if ( valeur == UNE_VALEUR):
                    comboAInitialiser.setCurrentIndex( idx)
                    break

    def initialiserListeMultiple( self, listWidget, LISTE_VALEURS_POSSIBLE, LISTE_VALEURS,  libelleErreur):
        """Initialise unne liste de valeur et avec la liste des valeurs correspondantes trouvés dans Settings
        """
        if len( LISTE_VALEURS_POSSIBLE) == 0:
            #listeAInitialiser.clear( )
            monPrint( self.tr("Pas de liste {0} pré défini".format( libelleErreur)), T_WAR,  "BAR", self)
            return
        if len( LISTE_VALEURS) == 0:
            monPrint( self.tr("Pas de liste {0} à sélectionner".format( libelleErreur)), T_WAR,  "BAR", self)
        else:
            listWidget.clear()
            listWidget.addItems( LISTE_VALEURS_POSSIBLE)

            for i in LISTE_VALEURS:
                matching_items = listWidget.findItems(i, Qt.MatchExactly)
                for item in matching_items:
                    item.setSelected(True)

    def slotLectureMesParcelles(self):
        # Choisir le CSV exporté de Mes Parcelles
        s = QgsSettings( APPLI_NOM)
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", os.path.join( self.plugin_dir, "data"))
        nomMesParcelles = s.value( "MonParcellaire/nomMesParcelles", "Export geometries parcelles2025_Fronton.csv")
        #propositionNomCompletMesParcelles = os.path.join( REPERTOIRE_GPKG, nomMesParcelles)
        nomCompletMesParcelles, _ = QFileDialog.getOpenFileName( self, self.tr("Choisir le CSV exporté de Mes Parcelles"),
                     REPERTOIRE_GPKG, "CSV (*.csv)");

        if len( nomCompletMesParcelles) == 0:
            return
        if not os.path.isfile( nomCompletMesParcelles):
            return
        self.Mes_Parcelles_lineEdit.setText( nomCompletMesParcelles)
        self.ecrireSettings()
        # TODO self.slotBasculeMesParcelles()       
        return

    def slotLectureRepertoireGPKG(self):
        # Choisir le répertoire
        s = QgsSettings( APPLI_NOM)
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", os.path.join( self.plugin_dir, "data"))
        nomRepertoire = QFileDialog.getExistingDirectory( self, self.tr("Choisir le répertoire de votre GPKG"),
                     REPERTOIRE_GPKG, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks);
        if len( nomRepertoire) == 0:
            return
        if not os.path.isdir( nomRepertoire):
            return
        self.Repertoire_lineEdit.setText( nomRepertoire )
        self.ecrireSettings()
        self.slotBasculeJointure()       
        return
        
    def ouvrirProjetETGroupe(self, nomDuGroupe):
        """ Ouvrir projet et un groupe"""

        # Vérification du projet ouverte
        monProjet = QgsProject.instance()
        if monProjet.fileName() == None or monProjet.fileName() == "":
            monPrint( "Projet en cours de création",  T_WAR)
        else:
            monPrint( "Projet ouvert {}".format(monProjet.fileName()))

        root = monProjet.layerTreeRoot()
        # Création du groupe jointure_date
        dateMaintenant = datetime.now()
        nomGroupe=nomDuGroupe + " du " + dateMaintenant.strftime("%d %b à %Hh%M:%S")
        temporaireGroupe = QgsLayerTreeGroup( nomGroupe)
        # Positionner en haut de root
        root.addChildNode(temporaireGroupe)
        nouveauGroupe = temporaireGroupe.clone()
        root.insertChildNode(0, nouveauGroupe)
        root.removeChildNode(temporaireGroupe)
        return monProjet, nouveauGroupe


    def fusionnerJointure(self, cheminCompletParcelle, jointureChoisie):
        """ Selon les tables déja ouverte dans le projet : ouverture si necessaire des différents cas de délimiteurs
            Jointure par QGIS """
        # Vérification du projet ouverte
        monProjet, nouveauGroupeJointure = self.ouvrirProjetETGroupe( MonParcellaire_JOI)
        # Ouverture du vecteur parcelle
        parcelle = QgsVectorLayer(cheminCompletParcelle, MonParcellaire_PAR+SEP_U+MonParcellaire_JOI, 'ogr')
        monProjet.addMapLayer(parcelle, False)
        nouveauGroupeJointure.addLayer( parcelle)
        
        # Recherche delimiteur
        delimiteur, csv, nomCsv = self.rechercherDelimiteurJointure( jointureChoisie, "No Pandas")
        nomCourtJointure = os.path.basename( jointureChoisie)

        monPrint( "Délimiteur identifié {0} pour {1}".format( delimiteur, nomCourtJointure), T_OK)
        monProjet.addMapLayer(csv, False)
        nouveauGroupeJointure.addLayer( csv)

        # Jointure
        attributsSelectionnes=self.AttributsAJoindre_listWidget.selectedItems()
        attributsAJoindre = []
        for positionAttribut in range(len(attributsSelectionnes)):
            attributsAJoindre.append( str(self.AttributsAJoindre_listWidget.selectedItems()[positionAttribut].text()))
        #monPrint( "Attributs à joindre {}".format( attributsAJoindre))
        # Liste des champs dans csv
        nomColonnes, _ = self.lireAttributsJointure( jointureChoisie)
        attributsAJoindreOrdonne = []
        for col in nomColonnes:
            if col in attributsAJoindre:
                if col != MonParcellaireNomAttribut:
                    attributsAJoindreOrdonne.append(col)
        #monPrint( "Attributs à joindre ordonné {}".format( attributsAJoindreOrdonne))

        champVecteur=MonParcellaireNomAttribut
        maJointure=QgsVectorLayerJoinInfo()
        champCsv=self.AttributJointure_comboBox.currentText()
        maJointure.setJoinFieldName( champCsv)
        maJointure.setTargetFieldName( champVecteur)
        maJointure.setUsingMemoryCache( True)
        maJointure.setPrefix( "")
        maJointure.setJoinLayer( csv)
        # Récupérer les champs de jointure
        maJointure.setJoinFieldNamesSubset( attributsAJoindreOrdonne)
        parcelle.addJoin( maJointure)
        return jointureChoisie, attributsAJoindreOrdonne

    def rechercherExtensionJointure( self, repertoireGPKG):
        """ Traite les différents cas d'extensions
            Rend la première jointure disponbile et la transforme en UTF-8 si necessaire
            ou None si il n'est existe aucune"""
        if not os.path.isdir (repertoireGPKG):
            erreurRepertoire( repertoireGPKG)
        for extension in EXTENSIONS_CONNUES:
            #monPrint( "Extension {0} pour repertoire {1}".format( extension, repertoireGPKG))
            CHEMIN_JOINTURE = nommageVecteur( repertoireGPKG, MonParcellaire_JOI, extension,  "Ne doit pas preexister")
            if os.path.isfile( CHEMIN_JOINTURE):
                break
        if not os.path.isfile( CHEMIN_JOINTURE):
            monWarning = "Aucune jointure disponible parmi {0}. Déposez la jointure dans votre référentiel : répertoire {1}".\
                format( EXTENSIONS_CONNUES, repertoireGPKG)
            monPrint( monWarning , T_WAR,  "BAR", self)
            monPrint( monWarning , T_WAR)
            return None
        # Détection encodage
        monFile = open(CHEMIN_JOINTURE, "rb")
        rawdata = monFile.read()
        detection = chardet.detect(rawdata)
        monFile.close()
        if detection['encoding'] == 'utf-8':
            CHEMIN_JOINTURE_UTF=CHEMIN_JOINTURE
        else:
            CHEMIN_JOINTURE_UTF= os.path.join( repertoireGPKG, MonParcellaire_JOI + "_UTF-8" + extension)
            monFile_UTF=open(CHEMIN_JOINTURE_UTF, "wb")
            monPrint( "Encodage {0} pour cette jointure pris en charge par Mon Parcellaire".format( detection['encoding']), T_OK)
            dataUTF=rawdata.decode(detection['encoding']).encode("utf-8")
            monFile_UTF.write( dataUTF)
            monFile_UTF.close()
        return CHEMIN_JOINTURE_UTF

#    def lireSignets(self):
#        import xml.etree.ElementTree as ET
#        
#        referentielPlugin=os.path.join( self.plugin_dir, "data")
#        mesSignets=os.path.join( referentielPlugin, "signets"+EXT_xml)
#        mesSignetsCSV=os.path.join( referentielPlugin, "signets"+EXT_csv)
#        if not os.path.isfile( mesSignets):
#            print("Pas de signets {}".format(mesSignets))
#            return
#
#        root = ET.parse(mesSignets).getroot()
#        if root.tag != "qgis_bookmarks":
#            print("Signets non QGIS")
#            return
#
#        tags = {"tags":[]}
#        for bookmark in root.iter('bookmark'):
##            name = bookmark.find('name').text
##            xmin = bookmark.find('xmin').text
##            monPrint( "Name et xmin : {0} {0} ".format( name,  xmin))
#            tag = {}
#            tag["name"] = bookmark.find('name').text
#            xmin = bookmark.find('xmin').text
#            ymin = bookmark.find('ymin').text
#            xmax = bookmark.find('xmax').text
#            ymax = bookmark.find('ymax').text
#            WKT = "MultiPolygon ((({0} {1}, {2} {1}, {2} {3}, {0} {3}, {0} {1})))".\
#                format( xmin, ymin, xmax, ymax)
#            tag["WKT"] = WKT
#
#            tags["tags"]. append(tag)
#        df_signets = pd.DataFrame(tags["tags"])
#        monPrint( "Signet : {}".format( df_signets.head()))
#        print( df_signets.head())        
#        df_signets.to_csv( mesSignetsCSV, sep=';')
#                
    def rechercherDelimiteurJointure( self, CHEMIN_JOINTURE, mode="Pandas"):
        """ Traite les différents cas de délimiteurs avec pandas ou QGIS"""
        if VERSION_PANDAS != None and mode == "Pandas":
            lesDelimiteurs=" "
            for delimiteur in DELIMITEURS_CONNUS:
                if delimiteur !='\t':
                    lesDelimiteurs=lesDelimiteurs+delimiteur+ " "
                else:
                    lesDelimiteurs=lesDelimiteurs+"TABULATION "
                try:
                    dfJointure = pd.read_csv( CHEMIN_JOINTURE,  sep="{}".format(delimiteur)) #, encoding=detection['encoding'])
                except:
                    monPrint( 'Délimiteur "{0}" ne convient pas au csv {1}'.format( delimiteur, CHEMIN_JOINTURE))
                    continue
                break           
            if dfJointure.empty:
                erreurJointureDelimeteurs( CHEMIN_JOINTURE, lesDelimiteurs)
                return None, None, None
            return delimiteur, dfJointure, None 
        else:
            for delimiteur in DELIMITEURS_CONNUS:
                nomCsv="file:///{1}?delimiter={0}".format( delimiteur, CHEMIN_JOINTURE)
                try:
                    csv = QgsVectorLayer(nomCsv, MonParcellaire_JOI, 'delimitedtext')               
                except:
                    monPrint( "Délimiteur {0} ne convient pas au csv {1}".format( delimiteur, nomCsv))
                    continue
                break
            #TODO Vx: attraper erreur ?    
            return delimiteur, csv, nomCsv
            
    def lireAttributsJointure(self, CHEMIN_JOINTURE):
        """ Lecture de la jointure dans Pandas, pour trouver attributs unique et avec doubles"""
        nomColonnes=[]
        nomColonnesUniques=[]
        if VERSION_PANDAS != None:
            _, dfJointure, _ = self.rechercherDelimiteurJointure( CHEMIN_JOINTURE)
            if dfJointure.empty:
                return nomColonnes, nomColonnesUniques
                    
            #monPrint("Liste des colonnes {}".format( listeColonnes))        
            for col in dfJointure.columns:                
                if col != MonParcellaireNomAttribut:
                    nomColonnes.append( col)
                listeJointureBrute=dfJointure[col].sort_values()
                listeJointureUnique=dfJointure[col].sort_values().unique()
                unique = True if len(listeJointureBrute) == len(listeJointureUnique) else False
                if unique:
                    nomColonnesUniques.append( col)
                    #monPrint("Colonne {0} est unique".format(col))
        else:
            _, layer, _ = self.rechercherDelimiteurJointure( CHEMIN_JOINTURE)
            #TEST: à vérifier
            if layer == None:
                return nomColonnes, nomColonnesUniques
            for field in layer.fields():
                #monPrint("Pas de {2} : champ du vecteur {0} a pour type {1}".format( field.name(), field.typeName(), E_PANDAS))
                nomColonnes.append( field.name())
            # Sans Pandas : mode dégradé pas de recherche des uniques
            nomColonnesUniques = nomColonnes
        if nomColonnesUniques == []:
            monPrint("Aucun attribut de cette jointure n'est unique: jointure impossible", T_ERR)
            monPrint("Aucun attribut de cette jointure n'est unique: jointure impossible", T_ERR,  T_BAR,  self)
            # Décocher le choix de jointure
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
        return nomColonnes, nomColonnesUniques
        
    def extraireVignesMesParcelles(self):
        """ Ouvrir CSV Mes Parcelles
        Renommer en nom le champ nom_parcelle
        Selectionnées les vignes
        """

        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
        monProjet, nouveauGroupeMP = self.ouvrirProjetETGroupe( MonParcellaire_MP)
        cheminCompletMesParcelle = self.Mes_Parcelles_lineEdit.text()
        uri="file:///"+cheminCompletMesParcelle+"?delimiter={}&wktField={}".format(",","geom")
        mes_parcelles = QgsVectorLayer(uri, \
              MonParcellaire_PAR+SEP_U+MonParcellaire_MP, 'delimitedtext')

        # Supprimer les colonnes inconnues
        ne_pas_detruire = ["nom_parcelle", "raisonsociale"]
        #with edit(mes_parcelles):
        all_fields = mes_parcelles.fields().names()
        #monPrint( "Champs {} dans Mes Parcelles".format( all_fields))

        champs_a_detruire = [mes_parcelles.fields().indexFromName(f) for f in all_fields if f not in ne_pas_detruire]
        monPrint( "Champs à detruire {} dans Mes Parcelles".format( champs_a_detruire))
        field_ids = [mes_parcelles.fields().indexFromName(f) for f in all_fields if f in ne_pas_detruire]
        #monPrint( "Champs à conserver {} dans Mes Parcelles".format( field_ids))
        mes_parcelles.dataProvider().deleteAttributes( champs_a_detruire)
        mes_parcelles.updateFields()

        monProjet.addMapLayer(mes_parcelles, False)
        nouveauGroupeMP.addLayer( mes_parcelles)
        # Forcer EPSG 2154 QgsCoordinateReferenceSystem constructor deprecated
        mes_parcelles.setCrs(QgsCoordinateReferenceSystem('EPSG:'+str(ID_DESTINATION_CRS)))


        # Filtrer les seules vignes
        try:
              nom_toutes_parcelles = os.path.join( REPERTOIRE_GPKG, "MES_PARCELLES_TOUTES"+EXT_geojson)
              traitementSauver( uri, nom_toutes_parcelles)
              toutes_parcelles = QgsVectorLayer(nom_toutes_parcelles, \
              		MesParcelles_GJ, "ogr")
              monProjet.addMapLayer(toutes_parcelles, False)
              traitementSelectionnerVignes( nom_toutes_parcelles)
              selection_input=QgsProcessingFeatureSourceDefinition( nom_toutes_parcelles, \
				selectedFeaturesOnly=True, \
				featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid)
              nom_vignes_attr = os.path.join( REPERTOIRE_GPKG, "MES_PARCELLES_ATTRS_VIGNES"+EXT_geojson)
              traitementSauver( selection_input, nom_vignes_attr)
              toutes_attr_vignes = QgsVectorLayer(nom_vignes_attr, \
              		MonParcellaireFiltre_GJ, "ogr")
              monProjet.addMapLayer(toutes_attr_vignes, False)
              nouveauGroupeMP.addLayer( toutes_attr_vignes)
        except:
              monPrint( "Vecteur {0} ne convient pas pour la sélection des vignes".format( uri), T_ERR)
              erreurTraitement("Sélection vignes")
        try:
              nom_vignes = os.path.join( REPERTOIRE_GPKG, "MES_PARCELLES_VIGNES"+EXT_geojson)
              traitementDupliquer_nom_parcelle( nom_vignes_attr, nom_vignes)
              toutes_vignes = QgsVectorLayer(nom_vignes, \
              		MonParcellaire_attr_MP, "ogr")
              monProjet.addMapLayer(toutes_vignes, False)
              # Supprimer les colonnes inconnues
              ne_pas_detruire = ["nom", "nom_parcelle", "raisonsociale"]
              #with edit(toutes_vignes):
              all_fields = toutes_vignes.fields().names()
              champs_a_detruire = [toutes_vignes.fields().indexFromName(f) for f in all_fields if f not in ne_pas_detruire]
              monPrint( "Champs à détruire {} dr Mes Parcelles".format( champs_a_detruire))
              field_ids = [toutes_vignes.fields().indexFromName(f) for f in all_fields if f in ne_pas_detruire]
              monPrint( "Champs à conserver {} de Mes Parcelles".format( field_ids))
              #TODO BUG on garde les trois premieres colonnes
              toutes_vignes.dataProvider().deleteAttributes( champs_a_detruire)
              toutes_vignes.updateFields()
              nouveauGroupeMP.addLayer( toutes_vignes)
        except:
              monPrint( "Vecteur {0} ne convient pas pour gerer attribut pour Mon Parcellaire la sélection des vignes".format( nom_vignes_attr), T_ERR)
              erreurTraitement("Sélection vignes")
        return mes_parcelles

    def slotTraiterRepertoireGPKGJointure( self):
        """ Gestion la sauvegarde du GPKG : trois cas de frequences de sauvegarde, 
            Gestion de la jointure    
        """
        monPrint( self.tr("Contrôle répertoire, sauvegarde GPKGs et jointure ... Version {0}".format(APPLI_VERSION)))
        
        # Utiliser les dernières saisies
        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
        FREQUENCE_SAUVEGARDE = self.FrequenceSauvegarde_comboBox.currentText()
        CHOIX_JOINTURE = "YES" if self.Jointure_checkBox.isChecked() else "NO"
        CHOIX_MES_PARCELLES = "YES" if self.Mes_Parcelles_checkBox.isChecked() else "NO"
        self.ecrireSettings()        
        ###############
        # Sauvegardes 
        ###############
        presenceObligatoire= True
        CHEMIN_VECTEUR_GPKG, cheminCompletParcelle = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MonParcellaire_GPKG, \
            FREQUENCE_SAUVEGARDE, MonParcellaire_SAV, presenceObligatoire, MonParcellaire_PAR)
        CHEMIN_RASTER_GPKG, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MesFondsDePlan_GPKG, \
            LISTE_FREQUENCE_SAUVEGARDE[3], MonParcellaire_SAV)
        CHEMIN_IEA_GPKG, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MesIAE_GPKG, \
            FREQUENCE_SAUVEGARDE, MonParcellaire_SAV)
        # Sauver tous les projets
        nomProjetRecherches = os.path.join( REPERTOIRE_GPKG, '*'+EXT_qgz)
        listeProjetTriee = sorted(glob.glob( nomProjetRecherches))
        monPrint( self.tr("Liste des projets QGIS {0}".format(listeProjetTriee)))
        for monProjet in listeProjetTriee:
            nomCourtprojet = os.path.basename( monProjet)
            _, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, nomCourtprojet, \
                FREQUENCE_SAUVEGARDE, MonParcellaire_SAV)
        ###############
        # Jointure 
        ###############                   
        if CHOIX_JOINTURE == "YES":
            # Déterminer le nom de la jointure (plusieurs extensions)
            jointureChoisie = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
            if jointureChoisie != None:
                if CHOIX_MES_PARCELLES == "YES":
                    mes_parcelles = self.extraireVignesMesParcelles()

                CHEMIN_JOINTURE,  attributsAJoindreOrdonne = \
                    self.fusionnerJointure( cheminCompletParcelle, jointureChoisie)
                nomCourtJointure = os.path.basename( CHEMIN_JOINTURE)
                REPERTOIRE_JOINTURE= os.path.dirname( CHEMIN_JOINTURE)
                _, _ = self.sauvergardeSelonFrequence( REPERTOIRE_JOINTURE, nomCourtJointure, \
                    LISTE_FREQUENCE_SAUVEGARDE[0], MonParcellaire_SAV,  presenceObligatoire)
                monPrint( self.tr("Fin : vérification répertoire, sauvegarde GPKGs et jointure {0} pour des attributs {1}".\
                    format(nomCourtJointure, attributsAJoindreOrdonne)), T_OK)
            else:
                monPrint( self.tr("Fin : vérification répertoire - pas de jointure et sauvegarde GPKGs"), T_OK)
        else:
            monPrint( self.tr("Fin : vérification répertoire et sauvegarde GPKGs"), T_OK)


    def traiterCentipedePos( self):
        """ Traiter les traces Centipede pos
            Creer des rangs ou interrangs dans le parcellaire
        """
        monPrint( self.tr("BOUTON en chantier : Traitement des traces centipedes ... Version {0} module {}".format(APPLI_VERSION, __name__)))
#        monProjet = QgsProject.instance()
#        root = monProjet.layerTreeRoot()
#        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
#        CHEMIN_GPKG, _, cheminCompletTable = nommagesGPKG( REPERTOIRE_GPKG, MonParcellaire_PAR, MonParcellaire_GPKG, True)  
#        _, nomPosChoisi = chercherDernierPosCentipede( CHEMIN_GPKG)     
#        monPrint( "Dernière trace est choisie {0}. Si vous voulez un autre traitement, renommer vos fichier bruts *.pos".format(nomPosChoisi))
#
#        NomRepertoireCentipede = os.path.join( REPERTOIRE_GPKG, REPERTOIRE_CENTIPEDE_W)
#        NomTamponInterieur, NomTamponExterieur = creerTamponsParcelles( baseGPKG, cheminCompletTable, NomRepertoireCentipede)
#        nomQ1_GeoJSON, nomQ2_GeoJSON = filtreQualitesCentipede( nomPosChoisi, NomRepertoireCentipede)
#        nomPointsCentipedeQ1INT, nomPointsCentipedeQ1EXT,  nomPointsCentipedeQ2EXT= projectionPourJointureSpatiale(nomQ1_GeoJSON, nomQ2_GeoJSON)
#        dfPointBrut, quelRendu = choisirGeoJSONsInterieurExterieur( nomPointsCentipedeQ1INT, nomPointsCentipedeQ1EXT, nomPointsCentipedeQ2EXT)
#
#        repertoireDesParcelles = os.path.join( NomRepertoireCentipede, REPERTOIRE_CENTIPEDE_PARCELLES)
#        creerRepertoireOptionTemporaire( repertoireDesParcelles)#

#        # PASSE1 : Passer en revu tous les points par parcelle et trouver les ruptures de temps (2 Secondes) ou de distance (2m) (< écartement rang ou de passage

#        creerPointsLignesBrises( dfPointBrut,  quelRendu)
#        monPrint( "{} Fin extraction des Points & Lignes brisées à partir de {}".format( E_CLAP, quelRendu),  T_OK)
