# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonParcellaireDockWidget
                                 A QGIS plugin
 Manage your parcels
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by jhemmi.eu
        email                : jean@jhemmi.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from .initialisation_var_exception import *

import os
import glob
import shutil # pour la copie de fichier
from datetime import datetime
from qgis.gui import ( QgsMessageBar)
from qgis.core import (
   QgsSettings, QgsProject, QgsVectorLayer, QgsVectorLayerJoinInfo, QgsLayerTreeGroup
  #QgsApplication, QgsWkbTypes, QgsVectorFileWriter, QgsCoordinateReferenceSystem, QgsFeature, QgsFields, QgsField
)

from PyQt5.QtCore import ( Qt, QUrl) #, QFileInfo)
from PyQt5.QtGui import ( QDesktopServices)
from PyQt5.QtWidgets import ( QDialogButtonBox, QFileDialog, QSizePolicy) # QGridLayout QDialog 
from qgis.PyQt import QtWidgets, uic # QtGui
from qgis.PyQt.QtCore import ( pyqtSignal) #, QVariant)

try:
    import pandas as pd
    VERSION_PANDAS=pd.__version__
    print("Version pandas : {0} ".format( VERSION_PANDAS))
#    import fiona # ou json
#    print("Drivers fiona : {0}".format(fiona.supported_drivers))
except:
    VERSION_PANDAS=None
    erreurImportVersion("pandas")
try:
    import chardet
except:
    erreurImportVersion("chardet")
#try:
#    import processing
#    from processing import ( QgsProcessingException) # algorithmHelp
#except:
#    erreurImport("Processing")
#    
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mon_parcellaire_dockwidget_base.ui'))
    
class MonParcellaireDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MonParcellaireDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # Barre de comm
        self.bar = QgsMessageBar()
        self.bar.setSizePolicy( QSizePolicy.Minimum, QSizePolicy.Fixed )

        self.plugin_dir = os.path.dirname(__file__) 
        
        #print( "** Démarrage de MonParcellaire {0}".format(APPLI_VERSION))
        CHOIX_TOUT_VOIR, CHOIX_JOINTURE, REPERTOIRE_GPKG, FREQUENCE_SAUVEGARDE, \
            ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE = self.lireSettings()
        # Slot boutons 
        self.Prepare_buttonBox.button( QDialogButtonBox.Ok ).pressed.connect(self.slotTraiterRepertoireGPKGJointure)
        self.Prepare_buttonBox.button( QDialogButtonBox.Save ).pressed.connect(self.ecrireSettings)
        self.TestButton.pressed.connect(self.lireSignets)

        # Slot toolbouton 
        self.Repertoire_toolButton.pressed.connect( self.slotLectureRepertoireGPKG)  
        self.Jointure_checkBox.stateChanged.connect( self.slotBasculeJointure)

        # Cas des combo
        self.initialiserCombo( self.FrequenceSauvegarde_comboBox, LISTE_FREQUENCE_SAUVEGARDE, FREQUENCE_SAUVEGARDE,  "des fréquences de sauvegarde")
        CHEMIN_JOINTURE = None
        if CHOIX_JOINTURE == "YES":
            # Déterminer le nom de la jointure
            CHEMIN_JOINTURE = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
        if CHEMIN_JOINTURE != None:
            nomColonnes, nomColonnesUniques = self.lireAttributsJointure( CHEMIN_JOINTURE)
        else:
            nomColonnes=['Pas de jointure']
            nomColonnesUniques=['Pas de jointure']
        # Attributs pour la joindre
        self.initialiserCombo( self.AttributJointure_comboBox, nomColonnesUniques, ATTRIBUT_JOINTURE)
        # Liste AttributsAJoindre
        self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, nomColonnes, LISTE_ATTRIBUTS_A_JOINDRE,  "attributs à joindre")
        # Cas où jointure est attendu mais n'existe pas (ou plus)
        if CHOIX_JOINTURE == "YES" and CHEMIN_JOINTURE == None:
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
            CHOIX_JOINTURE == "NO"
        else:
            self.Jointure_checkBox.setChecked( Qt.Checked)
            
        # Appel à aide ou contrib
        self.Aide_bouton.pressed.connect(self.slotDemanderAide)
        self.Contribuer_bouton.pressed.connect(self.slotDemanderContribution)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        
    def slotDemanderContribution( self):
        """ Pointer vers page paiement en ligne Paypal ou Stripe ou projet d'évolution contributif""" 
        help_url = QUrl("https://www.ma-sentinelle.eu/contributions")
        QDesktopServices.openUrl(help_url)
    
    def slotDemanderAide(self):
        """ Help html qui pointe vers gitHub""" 
        help_url = QUrl("https://github.com/jhemmi/MonParcellaire/wiki")
        QDesktopServices.openUrl(help_url)

    def ecrireSettings(self):
        """On écrit dans settings les saisies"""
        s = QgsSettings( APPLI_NOM)
        choixToutVoir = "YES" #if self.Voir_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Tout_voir", choixToutVoir)
        s.setValue("MonParcellaire/repertoireGPKG", self.Repertoire_lineEdit.text())
        s.setValue("MonParcellaire/FrequenceSauvegarde", self.FrequenceSauvegarde_comboBox.currentText())
        choixJointure = "YES" if self.Jointure_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/PresenceJointure", choixJointure)
        s.setValue("MonParcellaire/AttributJointure", self.AttributJointure_comboBox.currentText())
        # Multivalues
        items=self.AttributsAJoindre_listWidget.selectedItems()
        listeAJoindre = ""
        for item in range(len(items)):
            nomItem=str(self.AttributsAJoindre_listWidget.selectedItems()[item].text())
            if nomItem != MonParcellaireNomAttribut:
                if item == 0:
                    listeAJoindre=nomItem
                else:
                    listeAJoindre=listeAJoindre + SEP_CONFIG + nomItem
        s.setValue("MonParcellaire/AttributsAJoindre", listeAJoindre)
        #monPrint( "Settings sauvegardées")
        return

    def lireSettings( self):
        s = QgsSettings( APPLI_NOM)
        CHOIX_TOUT_VOIR = s.value("MonParcellaire/Tout_voir", "NO")
        CHOIX_JOINTURE = s.value("MonParcellaire/PresenceJointure", "NO")
        self.Jointure_checkBox.setChecked( Qt.Checked) if CHOIX_JOINTURE == "YES" else self.Jointure_checkBox.setChecked( Qt.Unchecked)
        referentiel_plugin=os.path.join( self.plugin_dir, "data")
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", referentiel_plugin)
        if not os.path.isdir( REPERTOIRE_GPKG): # n'existe plus
            monPrint( "Répertoire {0} n'existant plus, retour au choix du référentiel du plugin {1}".\
                format( REPERTOIRE_GPKG, referentiel_plugin), T_WAR)
            REPERTOIRE_GPKG = referentiel_plugin
        self.Repertoire_lineEdit.setText( REPERTOIRE_GPKG )
        FREQUENCE_SAUVEGARDE = s.value("MonParcellaire/FrequenceSauvegarde", LISTE_FREQUENCE_SAUVEGARDE[0])
        ATTRIBUT_JOINTURE = s.value("MonParcellaire/AttributJointure", "Pas de jointure")
        PreparelisteAttributAJoindre = s.value("MonParcellaire/AttributsAJoindre", "Pas de jointure")
        LISTE_ATTRIBUTS_A_JOINDRE=PreparelisteAttributAJoindre.split( SEP_CONFIG)
        #monPrint( "Settings lus jointure {} pour attributs {}".format( CHOIX_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE))
        return CHOIX_TOUT_VOIR, CHOIX_JOINTURE, REPERTOIRE_GPKG, FREQUENCE_SAUVEGARDE, ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE
    
    def nommageVecteur( self, Repertoire, nomVecteur, Extension=EXT_geojson, doitExister="Oui"):
        """ Calcule le nom du vecteur et vérifie si le chemin au vecteur existe
        Rend le nom """
        # Assert
        if not os.path.isdir( Repertoire):
            erreurRepertoire( Repertoire)
        chemin_complet = os.path.join( Repertoire, nomVecteur + Extension)
        if  doitExister == "Oui" and not os.path.isfile( chemin_complet):
            erreurVecteur( Repertoire,  nomVecteur + Extension)
        return chemin_complet
    
    def nommagesGPKG( self, Repertoire, nomTable, nomGPKG=MonParcellaire_GPKG, presenceAttendu=False):
        """ Calcule le nom de table et vérifie si le chemin au GPKG existe
        Rend le nom du gpkg, un libelle et le nom pour ouvrir avec QGIS API"""
        # Assert
        if not os.path.isdir( Repertoire):
            erreurRepertoire( Repertoire)
        CHEMIN_GPKG = os.path.join( Repertoire, nomGPKG)
        if not os.path.isfile( CHEMIN_GPKG):
            if presenceAttendu:
                erreurGPKG( nomGPKG,  CHEMIN_GPKG)
            return None, None, None
        #print( "nommageGPKG", CHEMIN_GPKG, "layer='{}'".format(nomTable), CHEMIN_GPKG + GPKG_LAYERNAME + nomTable)
        return CHEMIN_GPKG, "layer='{}'".format(nomTable), CHEMIN_GPKG + GPKG_LAYERNAME + nomTable

    def sauvergardeSelonFrequence(self, repertoireASauver, nomCourt, frequence, suiteSauvegarde, presenceAttendue=False, nomTable="xxx"):
        """ Fichier (y compris GPKG) est sauvés selon la fréquence et si nécessaire
            nommage detaillé selon la fréquence"""
        REPERTOIRE_SAUVEGARDE = os.path.join( repertoireASauver, suiteSauvegarde)
        if not os.path.isdir( REPERTOIRE_SAUVEGARDE):
            os.mkdir( REPERTOIRE_SAUVEGARDE)
        # Déterminer les noms des gpkg pour les copier
        CHEMIN_GPKG, _, cheminCompletTable = self.nommagesGPKG( repertoireASauver, nomTable, nomCourt, presenceAttendue)  
        if CHEMIN_GPKG == None:
            monPrint( "Pas de sauvegarde pour {0}".format( nomCourt), T_WAR)            
            return None, None
        dateMaintenant = datetime.now()
        if frequence == LISTE_FREQUENCE_SAUVEGARDE[0]: # prochain run
            dateFormatee=dateMaintenant.strftime("%Y%m%d%H%M")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[1]: # par jour
            dateFormatee=dateMaintenant.strftime("%Y%m%d")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[2]: # par semaine
            dateFormatee=dateMaintenant.strftime("%Y%mSemaine%U")
        else: # par mois
            assert( frequence == LISTE_FREQUENCE_SAUVEGARDE[3])
            dateFormatee=dateMaintenant.strftime("%Y%m")
        CHEMIN_GPKG_SAVE = os.path.join( REPERTOIRE_SAUVEGARDE,  nomCourt) + "_SAUVEGARDE_" + dateFormatee
        if not os.path.isfile( CHEMIN_GPKG_SAVE):
            shutil.copy( CHEMIN_GPKG, CHEMIN_GPKG_SAVE)
        return CHEMIN_GPKG, cheminCompletTable

    def slotBasculeJointure( self):
        """ 
        Bascule le choix jointure et acces aux listes d'attribut à joindre
        """
        CHEMIN_JOINTURE=None
        if self.Jointure_checkBox.isChecked():
            _, _, REPERTOIRE_GPKG, _, \
            ATTRIBUT_JOINTURE, LISTE_ATTRIBUTS_A_JOINDRE = self.lireSettings()
            CHEMIN_JOINTURE = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
        if CHEMIN_JOINTURE != None and self.Jointure_checkBox.isChecked():
            self.AttributJointure_comboBox.setEnabled( True)
            self.AttributsAJoindre_listWidget.setEnabled( True)
            self.label_Jointure.setEnabled( True)
            self.label_AttributJointure.setEnabled( True)
            self.label_AttributsAJoindre.setEnabled( True)
            nomColonnes, nomColonnesUniques = self.lireAttributsJointure( CHEMIN_JOINTURE)
            # Attributs pour la joindre
            self.initialiserCombo( self.AttributJointure_comboBox, nomColonnesUniques, ATTRIBUT_JOINTURE)
            # Liste AttributsAJoindre
            self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, nomColonnes, LISTE_ATTRIBUTS_A_JOINDRE,  "attributs à joindre")
        else:
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
            self.AttributJointure_comboBox.setEnabled( False)
            self.AttributsAJoindre_listWidget.setEnabled( False)
            self.label_Jointure.setEnabled( False)
            self.label_AttributJointure.setEnabled( False)
            self.label_AttributsAJoindre.setEnabled( False)
            self.initialiserCombo( self.AttributJointure_comboBox, ["Pas de jointure"], "Pas de jointure")
            self.initialiserListeMultiple( self.AttributsAJoindre_listWidget, ["Pas de jointure"], ["Pas de jointure"], "attributs à joindre")
            
    def initialiserCombo( self, comboAInitialiser, LISTE_VALEURS, UNE_VALEUR,  libelleErreur=None):
        """Initialise un combo avec une liste de valeur et avec la position de la valeur correspondante trouvé dans Settings
        """
        comboAInitialiser.setCurrentIndex( 0)
        if len( LISTE_VALEURS) == 0:
            comboAInitialiser.clear()
            if libelleErreur != None:
                monPrint( self.tr("Pas de liste {0} pré défini".format( libelleErreur)), T_WAR,  "BAR", self)
        else:
            comboAInitialiser.clear( )
            comboAInitialiser.addItems( LISTE_VALEURS )
            # Retrouver le mode de trace dans  settings
            for idx, valeur in enumerate( LISTE_VALEURS):
                if ( valeur == UNE_VALEUR):
                    comboAInitialiser.setCurrentIndex( idx)
                    break

    def initialiserListeMultiple( self, listWidget, LISTE_VALEURS_POSSIBLE, LISTE_VALEURS,  libelleErreur):
        """Initialise unne liste de valeur et avec la liste des valeurs correspondantes trouvés dans Settings
        """
        if len( LISTE_VALEURS_POSSIBLE) == 0:
            #listeAInitialiser.clear( )
            monPrint( self.tr("Pas de liste {0} pré défini".format( libelleErreur)), T_WAR,  "BAR", self)
            return
        if len( LISTE_VALEURS) == 0:
            monPrint( self.tr("Pas de liste {0} à sélectionner".format( libelleErreur)), T_WAR,  "BAR", self)
        else:
            listWidget.clear()
            listWidget.addItems( LISTE_VALEURS_POSSIBLE)

            for i in LISTE_VALEURS:
                matching_items = listWidget.findItems(i, Qt.MatchExactly)
                for item in matching_items:
                    item.setSelected(True)
        
    def slotLectureRepertoireGPKG(self):
        # Choisir le répertoire
        s = QgsSettings( APPLI_NOM)
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", os.path.join( self.plugin_dir, "data"))
        nomRepertoire = QFileDialog.getExistingDirectory( self, self.tr("Choisir le répertoire de votre GPKG"),
                     REPERTOIRE_GPKG, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks);
        if len( nomRepertoire) == 0:
            return
        if not os.path.isdir( nomRepertoire):
            return
        self.Repertoire_lineEdit.setText( nomRepertoire )
        self.ecrireSettings()
        self.slotBasculeJointure()       
        return
        
    def fusionnerJointure(self, cheminCompletParcelle, jointureChoisie):
        """ Selon les tables déja ouverte dans le projet : ouverture si necessaire des différents cas de délimiteurs
            Jointure par QGIS """
        # Vérification du projet ouverte
        monProjet = QgsProject.instance()
        if monProjet.fileName() == None or monProjet.fileName() == "":
            monPrint( "Projet en cours de création",  T_WAR)
        else:
            monPrint( "Projet ouvert {}".format(monProjet.fileName()))

        root = monProjet.layerTreeRoot()
        # Création du groupe jointure_date
        dateMaintenant = datetime.now()
        nomGroupe=MonParcellaire_JOI + " du " + dateMaintenant.strftime("%d %b à %Hh%M:%S")
        temporaireGroupe = QgsLayerTreeGroup( nomGroupe)
        # Positionner en haut de root
        root.addChildNode(temporaireGroupe)
        nouveauGroupe = temporaireGroupe.clone()
        root.insertChildNode(0, nouveauGroupe)
        root.removeChildNode(temporaireGroupe)
        
        # Ouverture du vecteur parcelle
        parcelle =  QgsVectorLayer(cheminCompletParcelle, MonParcellaire_PAR+SEP_U+MonParcellaire_JOI, 'ogr')
        monProjet.addMapLayer(parcelle, False)
        nouveauGroupe.addLayer( parcelle)
      
        # Recherche delimiteur
        delimiteur, csv, nomCsv = self.rechercherDelimiteurJointure( jointureChoisie, "No Pandas")
        nomCourtJointure = os.path.basename( jointureChoisie)

        monPrint( "Délimiteur identifié {0} pour {1}".format( delimiteur, nomCourtJointure), T_OK)
        monProjet.addMapLayer(csv, False)
        nouveauGroupe.addLayer( csv)

        # Jointure
        attributsSelectionnes=self.AttributsAJoindre_listWidget.selectedItems()
        attributsAJoindre = []
        for positionAttribut in range(len(attributsSelectionnes)):
            attributsAJoindre.append( str(self.AttributsAJoindre_listWidget.selectedItems()[positionAttribut].text()))
        #monPrint( "Attributs à joindre {}".format( attributsAJoindre))
        # Liste des champs dans csv
        nomColonnes, _ = self.lireAttributsJointure( jointureChoisie)
        attributsAJoindreOrdonne = []
        for col in nomColonnes:
            if col in attributsAJoindre:
                if col != MonParcellaireNomAttribut:
                    attributsAJoindreOrdonne.append(col)
        #monPrint( "Attributs à joindre ordonné {}".format( attributsAJoindreOrdonne))

        champVecteur=MonParcellaireNomAttribut
        maJointure=QgsVectorLayerJoinInfo()
        champCsv=self.AttributJointure_comboBox.currentText()
        maJointure.setJoinFieldName( champCsv)
        maJointure.setTargetFieldName( champVecteur)
        maJointure.setUsingMemoryCache( True)
        maJointure.setPrefix( "")
        maJointure.setJoinLayer( csv)
        # Récupérer les champs de jointure
        maJointure.setJoinFieldNamesSubset( attributsAJoindreOrdonne)
        parcelle.addJoin( maJointure)
        return jointureChoisie, attributsAJoindreOrdonne

    def rechercherExtensionJointure( self, repertoireGPKG):
        """ Traite les différents cas d'extensions
            Rend la première jointure disponbile et la transforme en UTF-8 si necessaire
            ou None si il n'est existe aucune"""
        if not os.path.isdir (repertoireGPKG):
            erreurRepertoire( repertoireGPKG)
        for extension in EXTENSIONS_CONNUES:
            #monPrint( "Extension {0} pour repertoire {1}".format( extension, repertoireGPKG))
            CHEMIN_JOINTURE = self.nommageVecteur( repertoireGPKG, MonParcellaire_JOI, extension,  "Ne doit pas preexister")
            if os.path.isfile( CHEMIN_JOINTURE):
                break
        if not os.path.isfile( CHEMIN_JOINTURE):
            monWarning = "Aucune jointure disponible parmi {0}. Déposez la jointure dans votre référentiel : répertoire {1}".\
                format( EXTENSIONS_CONNUES, repertoireGPKG)
            monPrint( monWarning , T_WAR,  "BAR", self)
            monPrint( monWarning , T_WAR)
            return None
        # Détection encodage
        monFile = open(CHEMIN_JOINTURE, "rb")
        rawdata = monFile.read()
        detection = chardet.detect(rawdata)
        monFile.close()
        if detection['encoding'] == 'utf-8':
            CHEMIN_JOINTURE_UTF=CHEMIN_JOINTURE
        else:
            CHEMIN_JOINTURE_UTF= os.path.join( repertoireGPKG, MonParcellaire_JOI + "_UTF-8" + extension)
            monFile_UTF=open(CHEMIN_JOINTURE_UTF, "wb")
            monPrint( "Encodage {0} pour cette jointure pris en charge par Mon Parcellaire".format( detection['encoding']), T_OK)
            dataUTF=rawdata.decode(detection['encoding']).encode("utf-8")
            monFile_UTF.write( dataUTF)
            monFile_UTF.close()
        return CHEMIN_JOINTURE_UTF

    def lireSignets(self):
        import xml.etree.ElementTree as ET
        
        referentielPlugin=os.path.join( self.plugin_dir, "data")
        mesSignets=os.path.join( referentielPlugin, "signets"+EXT_xml)
        mesSignetsCSV=os.path.join( referentielPlugin, "signets"+EXT_csv)
        if not os.path.isfile( mesSignets):
            print("Pas de signets {}".format(mesSignets))
            return

        root = ET.parse(mesSignets).getroot()
        if root.tag != "qgis_bookmarks":
            print("Signets non QGIS")
            return

        tags = {"tags":[]}
        for bookmark in root.iter('bookmark'):
#            name = bookmark.find('name').text
#            xmin = bookmark.find('xmin').text
#            monPrint( "Name et xmin : {0} {0} ".format( name,  xmin))
            tag = {}
            tag["name"] = bookmark.find('name').text
            xmin = bookmark.find('xmin').text
            ymin = bookmark.find('ymin').text
            xmax = bookmark.find('xmax').text
            ymax = bookmark.find('ymax').text
            WKT = "MultiPolygon ((({0} {1}, {2} {1}, {2} {3}, {0} {3}, {0} {1})))".\
                format( xmin, ymin, xmax, ymax)
            tag["WKT"] = WKT

            tags["tags"]. append(tag)
        df_signets = pd.DataFrame(tags["tags"])
        monPrint( "Signet : {}".format( df_signets.head()))
        print( df_signets.head())        
        df_signets.to_csv( mesSignetsCSV, sep=';')
                
    def rechercherDelimiteurJointure( self, CHEMIN_JOINTURE, mode="Pandas"):
        """ Traite les différents cas de délimiteurs avec pandas ou QGIS"""
        if VERSION_PANDAS != None and mode == "Pandas":
            lesDelimiteurs=" "
            for delimiteur in DELIMITEURS_CONNUS:
                if delimiteur !='\t':
                    lesDelimiteurs=lesDelimiteurs+delimiteur+ " "
                else:
                    lesDelimiteurs=lesDelimiteurs+"TABULATION "
                try:
                    dfJointure = pd.read_csv( CHEMIN_JOINTURE,  sep="{}".format(delimiteur)) #, encoding=detection['encoding'])
                except:
                    monPrint( 'Délimiteur "{0}" ne convient pas au csv {1}'.format( delimiteur, CHEMIN_JOINTURE))
                    continue
                break           
            if dfJointure.empty:
                erreurJointureDelimeteurs( CHEMIN_JOINTURE, lesDelimiteurs)
                return None, None, None
            return delimiteur, dfJointure, None 
        else:
            for delimiteur in DELIMITEURS_CONNUS:
                nomCsv="file:///{1}?delimiter={0}".format( delimiteur, CHEMIN_JOINTURE)
                try:
                    csv = QgsVectorLayer(nomCsv, MonParcellaire_JOI, 'delimitedtext')               
                except:
                    monPrint( "Délimiteur {0} ne convient pas au csv {1}".format( delimiteur, nomCsv))
                    continue
                break
            #TODO: attraper erreur ?    
            return delimiteur, csv, nomCsv
            
    def lireAttributsJointure(self, CHEMIN_JOINTURE):
        """ Lecture de la jointure dans Pandas, pour trouver attributs unique et avec doubles"""
        nomColonnes=[]
        nomColonnesUniques=[]
        if VERSION_PANDAS != None:
            _, dfJointure, _ = self.rechercherDelimiteurJointure( CHEMIN_JOINTURE)
            if dfJointure.empty:
                return nomColonnes, nomColonnesUniques
                    
            #monPrint("Liste des colonnes {}".format( listeColonnes))        
            for col in dfJointure.columns:                
                if col != MonParcellaireNomAttribut:
                    nomColonnes.append( col)
                listeJointureBrute=dfJointure[col].sort_values()
                listeJointureUnique=dfJointure[col].sort_values().unique()
                unique = True if len(listeJointureBrute) == len(listeJointureUnique) else False
                if unique:
                    nomColonnesUniques.append( col)
                    #monPrint("Colonne {0} est unique".format(col))
        else:
            _, layer, _ = self.rechercherDelimiteurJointure( CHEMIN_JOINTURE)
            #TEST: à vérifier
            if layer == None:
                return nomColonnes, nomColonnesUniques
            for field in layer.fields():
                monPrint("Pas de {2} : champ du vecteur {0} a pour type {1}".format( field.name(), field.typeName(), E_PANDAS))
                nomColonnes.append( field.name())
            # Sans Pandas : mode dégradé pas de recherche des uniques
            nomColonnesUniques = nomColonnes
        if nomColonnesUniques == []:
            monPrint("Aucun attribut de cette jointure n'est unique: jointure impossible", T_ERR)
            monPrint("Aucun attribut de cette jointure n'est unique: jointure impossible", T_ERR,  T_BAR,  self)
            # Décocher le choix de jointure
            self.Jointure_checkBox.setChecked( Qt.Unchecked)
        return nomColonnes, nomColonnesUniques
        
    def slotTraiterRepertoireGPKGJointure( self):
        """ Gestion la sauvegarde du GPKG : trois cas de frequences de sauvegarde, 
            Gestion de la jointure    
        """
        monPrint( self.tr("Contrôle répertoire, sauvegarde GPKGs et jointure ... Version {0}".format(APPLI_VERSION)))
        
        # Utiliser les dernières saisies
        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
        FREQUENCE_SAUVEGARDE = self.FrequenceSauvegarde_comboBox.currentText()
        CHOIX_JOINTURE = "YES" if self.Jointure_checkBox.isChecked() else "NO"
        self.ecrireSettings()        
        ###############
        # Sauvegardes 
        ###############
        presenceObligatoire= True
        CHEMIN_VECTEUR_GPKG, cheminCompletParcelle = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MonParcellaire_GPKG, \
            FREQUENCE_SAUVEGARDE, MonParcellaire_SAV, presenceObligatoire, MonParcellaire_PAR)
        CHEMIN_RASTER_GPKG, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MesFondsDePlan_GPKG, \
            LISTE_FREQUENCE_SAUVEGARDE[3], MonParcellaire_SAV)
        CHEMIN_IEA_GPKG, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, MesIAE_GPKG, \
            FREQUENCE_SAUVEGARDE, MonParcellaire_SAV)
        # Sauver tous les projets
        nomProjetRecherches = os.path.join( REPERTOIRE_GPKG, '*'+EXT_qgz)
        listeProjetTriee = sorted(glob.glob( nomProjetRecherches))
        monPrint( self.tr("Liste des projets {0}".format(listeProjetTriee)))
        for monProjet in listeProjetTriee:
            nomCourtprojet = os.path.basename( monProjet)
            _, _ = self.sauvergardeSelonFrequence( REPERTOIRE_GPKG, nomCourtprojet, \
                FREQUENCE_SAUVEGARDE, MonParcellaire_SAV)
        ###############
        # Jointure 
        ###############                   
        if CHOIX_JOINTURE == "YES":
            # Déterminer le nom de la jointure (plusieurs extensions)
            jointureChoisie = self.rechercherExtensionJointure( REPERTOIRE_GPKG)
            if jointureChoisie != None:
                CHEMIN_JOINTURE,  attributsAJoindreOrdonne = \
                    self.fusionnerJointure( cheminCompletParcelle, jointureChoisie)
                nomCourtJointure = os.path.basename( CHEMIN_JOINTURE)
                REPERTOIRE_JOINTURE= os.path.dirname( CHEMIN_JOINTURE)
                _, _ = self.sauvergardeSelonFrequence( REPERTOIRE_JOINTURE, nomCourtJointure, \
                    LISTE_FREQUENCE_SAUVEGARDE[0], MonParcellaire_SAV,  presenceObligatoire)
                monPrint( self.tr("Fin : vérification répertoire, sauvegarde GPKGs et jointure {0} pour des attributs {1}".\
                    format(nomCourtJointure, attributsAJoindreOrdonne)), T_OK)
            else:
                monPrint( self.tr("Fin : vérification répertoire - pas de jointure et sauvegarde GPKGs"), T_OK)
        else:
            monPrint( self.tr("Fin : vérification répertoire et sauvegarde GPKGs"), T_OK)
