# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonParcellaireDockWidget
                                 A QGIS plugin
 Manage your parcels
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by jhemmi.eu
        email                : jean@jhemmi.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from .initialisation_var_exception import *

import os
import shutil # pour la copie de fichier
from datetime import datetime
from qgis.gui import ( QgsMessageBar)
from qgis.core import (
  QgsApplication, QgsSettings, QgsProject, QgsWkbTypes, QgsVectorFileWriter, QgsCoordinateReferenceSystem, 
  QgsFeature, QgsFields, QgsField
)


from PyQt5.QtCore import (Qt) #, QFileInfo)  
from PyQt5.QtWidgets import (QDialogButtonBox, QFileDialog, QSizePolicy) # QGridLayout QDialog 
from qgis.PyQt import QtWidgets, uic # QtGui
from qgis.PyQt.QtCore import ( pyqtSignal, QVariant)

try:
    import pandas as pd
    #import json
    print("\nVersion pandas : {0} ".format(pd.__version__))
#    import fiona; 
#    print("Drivers fiona : {0}".format(fiona.supported_drivers))
except:
    erreur_import("Pandas") #erreur_import("Pandas ou geopandas")
#try:
#    import processing
#    from processing import ( QgsProcessingException) # algorithmHelp
#except:
#    erreur_import("Processing")
#    
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mon_parcellaire_dockwidget_base.ui'))
    
class MonParcellaireDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MonParcellaireDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # Barre de comm
        self.bar = QgsMessageBar()
        self.bar.setSizePolicy( QSizePolicy.Minimum, QSizePolicy.Fixed )
        
        print( "** Démarrage de MonParcellaire {0}".format(APPLI_VERSION))
        # Slot boutons 
        self.Prepare_buttonBox.button( QDialogButtonBox.Ok ).pressed.connect(self.slotVerifierRepertoireGPKGJointure)
        self.Prepare_buttonBox.button( QDialogButtonBox.Save ).pressed.connect(self.ecrireSettings)
        # Slot toolbouton 
        self.Repertoire_toolButton.pressed.connect( self.slotLectureRepertoireGPKG)  
#        self.MultiPoint_checkBox.stateChanged.connect( self.slotBasculeMultiPoints)

        CHOIX_TOUT_VOIR, REPERTOIRE_GPKG,  FREQUENCE_SAUVEGARDE = self.lireSettings()
        self.slotInitCombo( self.FrequenceSauvegarde_comboBox, LISTE_FREQUENCE_SAUVEGARDE, FREQUENCE_SAUVEGARDE,  "des fréquences de sauvegarde")

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def ecrireSettings(self):
        """On écrit dans settings les saisies"""
        s = QgsSettings( APPLI_NOM)
        choixToutVoir = "YES" if self.Voir_checkBox.isChecked() else "NO"
        s.setValue("MonParcellaire/Tout_voir", choixToutVoir)
        s.setValue("MonParcellaire/repertoireGPKG", self.Repertoire_lineEdit.text())
        s.setValue("MonParcellaire/FrequenceSauvegarde", self.FrequenceSauvegarde_comboBox.currentText())
#        libItineraire = "QGIS" if self.QGIS_radioButton.isChecked() else "QN"
#        s.setValue("MonParcellaire/LibItineraire", libItineraire)
        #my_print( "Settings sauvegardées")
        return

    def lireSettings( self):
        s = QgsSettings( APPLI_NOM)
        CHOIX_TOUT_VOIR = s.value("MonParcellaire/Tout_voir", "NO")
        REPERTOIRE_GPKG = s.value( "MonParcellaire/repertoireGPKG", "/media/jean/DATA/GIS/DATA/DATA_MP")
        FREQUENCE_SAUVEGARDE = s.value("MonParcellaire/FrequenceSauvegarde", LISTE_FREQUENCE_SAUVEGARDE[0])
        # Choisir library calcul itineraire
        #LIB_ITINERAIRE = s.value("MonParcellaire/LibItineraire", "QGIS")
        return CHOIX_TOUT_VOIR, REPERTOIRE_GPKG, FREQUENCE_SAUVEGARDE #, LIB_ITINERAIRE

    def nommages_gpkg( self, Repertoire, nomVecteur, nomGPKG=MonParcellaire_GPKG, doitExister="Oui"):
        """ Calcule le nom du vecteur et vérifie si le chemin au vecteur existe
        Rend le nom du gpkg, le nom pour ouvrir avec QGIS API"""
        # Assert
        if not os.path.isdir( Repertoire):
            erreur_repertoire( Repertoire)
        CHEMIN_GPKG = os.path.join( Repertoire, nomGPKG)
        if not os.path.isfile( CHEMIN_GPKG) and doitExister == "Oui":
            erreur_gpkg( nomGPKG,  CHEMIN_GPKG)
        return CHEMIN_GPKG, "layer='{}'".format(nomVecteur), CHEMIN_GPKG + GPKG_LAYERNAME + nomVecteur

    def sauvergardeGPKGs(self, repertoireGPKG, suiteSauvegarde, frequence):
        """ Deux GPKG sont sauvés selon la fréquence et si nécessaire"""
        REPERTOIRE_SAUVEGARDE = os.path.join( repertoireGPKG, suiteSauvegarde)
        if not os.path.isdir( REPERTOIRE_SAUVEGARDE):
            os.mkdir( REPERTOIRE_SAUVEGARDE)
        # ON determine les noms des gpkg pour les copier
        CHEMIN_GPKG, _,  _ = self.nommages_gpkg( repertoireGPKG, "xxx")  
        CHEMIN_GPKG_RASTER, _,  _ = self.nommages_gpkg( repertoireGPKG, "xxx", MesFondsDeCarte_GPKG)
        dateMaintenant = datetime.now()
        if frequence == LISTE_FREQUENCE_SAUVEGARDE[0]: # prochain run
            dateFormatee=dateMaintenant.strftime("%Y%m%d%H%M")
        elif frequence == LISTE_FREQUENCE_SAUVEGARDE[1]: # par jour
            dateFormatee=dateMaintenant.strftime("%Y%m%d")
        else: # par semaine
            assert( frequence == LISTE_FREQUENCE_SAUVEGARDE[2])
            dateFormatee=dateMaintenant.strftime("%Y%mSemaine%U")
        CHEMIN_GPKG_VECTEUR_SAVE = os.path.join( REPERTOIRE_SAUVEGARDE,  MonParcellaire_GPKG) + "_SAUVEGARDE_" + dateFormatee
        if not os.path.isfile( CHEMIN_GPKG_VECTEUR_SAVE):
            shutil.copy( CHEMIN_GPKG, CHEMIN_GPKG_VECTEUR_SAVE)
        CHEMIN_GPKG_RASTER_SAVE = os.path.join( REPERTOIRE_SAUVEGARDE,  MesFondsDeCarte_GPKG) + "_SAUVEGARDE_" + dateFormatee
        if not os.path.isfile( CHEMIN_GPKG_RASTER_SAVE):
            shutil.copy( CHEMIN_GPKG_RASTER, CHEMIN_GPKG_RASTER_SAVE)
        return CHEMIN_GPKG, CHEMIN_GPKG_RASTER, CHEMIN_GPKG_VECTEUR_SAVE, CHEMIN_GPKG_RASTER_SAVE

    def slotInitCombo( self, comboAInitialiser, LISTE_VALEURS, UNE_VALEUR,  libelleErreur):
        """Initialise un combo avec une liste de valeur et avec la position de la valeur correspondante trouvé dans Settings
        """
        comboAInitialiser.setCurrentIndex( 0)
        if len( LISTE_VALEURS) == 0:
            comboAInitialiser.clear( )
            my_print( self.tr("Pas de liste {0} pré défini".format( libelleErreur), T_WAR,  "BAR", self))
        else:
            comboAInitialiser.clear( )
            comboAInitialiser.addItems( LISTE_VALEURS )
            # Retrouver le mode de trace dans  settings
            for idx, valeur in enumerate( LISTE_VALEURS):
                if ( valeur == UNE_VALEUR):
                    comboAInitialiser.setCurrentIndex( idx)
                    break
                    
    def slotLectureRepertoireGPKG(self):
        # Repertoire
        s = QgsSettings( APPLI_NOM)
        TOM_REPERTOIRE = s.value( "MonTomParcellaire/Répertoire_gpkg", "Arretez vous au répertoire")
        dirName = QFileDialog.getExistingDirectory( self, self.tr(u'Choisir le répertoire de votre GPKG'),
                     TOM_REPERTOIRE, QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks);
        if len( dirName) == 0:
            return
        self.Repertoire_lineEdit.setText( dirName )
        return
        
    def slotVerifierRepertoireGPKGJointure( self):
        """ Gestion la sauvegarde du GPKG : trois cas de frequences de sauvegarde, 
            Gestion de la jointure    
        """
        my_print( self.tr("Vérifier répertoire et GPKG ... Version {0}".format(APPLI_VERSION)))
        
        # Utiliser les dernières saisies
        REPERTOIRE_GPKG = self.Repertoire_lineEdit.text()
        FREQUENCE_SAUVEGARDE = self.FrequenceSauvegarde_comboBox.currentText()
        ###############
        # Sauvegarde 
        ###############
        CHEMIN_GPKG, _, _, _ = self.sauvergardeGPKGs(REPERTOIRE_GPKG, MonParcellaire_SAV, FREQUENCE_SAUVEGARDE)
        ###############
        # Jointure 
        ###############                   
        
        self.ecrireSettings()        
        my_print( self.tr("Fin Vérifier répertoire et GPKG", T_OK))
